import math
import time
from typing import Iterable, List, Optional, Tuple

from aiogram import Dispatcher, F, types
from aiogram.filters import BaseFilter, StateFilter
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from app.database.models import User
from app.localization.texts import get_texts
from app.services.system_settings_service import bot_configuration_service
from app.states import BotConfigStates
from app.utils.decorators import admin_required, error_handler


CATEGORY_PAGE_SIZE = 10
SETTINGS_PAGE_SIZE = 8


CATEGORY_GROUP_DEFINITIONS: Tuple[Tuple[str, str, Tuple[str, ...]], ...] = (
    (
        "core",
        "‚öôÔ∏è –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
        (
            "DEFAULT",
            "ADMIN",
            "SUPPORT",
            "REMNAWAVE",
            "VERSION",
            "DEBUG",
            "LOG",
            "BACKUP",
        ),
    ),
    (
        "infrastructure",
        "üóÑÔ∏è –ò–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞",
        ("DATABASE", "POSTGRES", "SQLITE", "REDIS", "WEBHOOK", "SERVER", "MONITORING", "MAINTENANCE"),
    ),
    (
        "billing",
        "üí≥ –û–ø–ª–∞—Ç—ã –∏ —Ç–∞—Ä–∏—Ñ—ã",
        ("PRICE", "PAYMENT", "YOOKASSA", "CRYPTOBOT", "MULENPAY", "PAL24", "AUTOPAY", "TRIAL"),
    ),
    (
        "communication",
        "üì° –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏ –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏",
        ("CONNECT", "CHANNEL", "TELEGRAM", "HAPP"),
    ),
    (
        "loyalty",
        "üéÅ –†–µ—Ñ–µ—Ä–∞–ª—ã –∏ –ª–æ—è–ª—å–Ω–æ—Å—Ç—å",
        ("REFERRAL", "TRIBUTE"),
    ),
)

CATEGORY_FALLBACK_KEY = "other"
CATEGORY_FALLBACK_TITLE = "üì¶ –ü—Ä–æ—á–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"


async def _store_setting_context(
    state: FSMContext,
    *,
    key: str,
    group_key: str,
    category_page: int,
    settings_page: int,
) -> None:
    await state.update_data(
        setting_key=key,
        setting_group_key=group_key,
        setting_category_page=category_page,
        setting_settings_page=settings_page,
        botcfg_origin="bot_config",
        botcfg_timestamp=time.time(),
    )


class BotConfigInputFilter(BaseFilter):
    def __init__(self, timeout: float = 300.0) -> None:
        self.timeout = timeout

    async def __call__(
        self,
        message: types.Message,
        state: FSMContext,
    ) -> bool:
        if not message.text or message.text.startswith("/"):
            return False

        if message.chat.type != "private":
            return False

        data = await state.get_data()

        if data.get("botcfg_origin") != "bot_config":
            return False

        if not data.get("setting_key"):
            return False

        timestamp = data.get("botcfg_timestamp")
        if timestamp is None:
            return True

        try:
            return (time.time() - float(timestamp)) <= self.timeout
        except (TypeError, ValueError):
            return False


def _chunk(buttons: Iterable[types.InlineKeyboardButton], size: int) -> Iterable[List[types.InlineKeyboardButton]]:
    buttons_list = list(buttons)
    for index in range(0, len(buttons_list), size):
        yield buttons_list[index : index + size]


def _parse_category_payload(payload: str) -> Tuple[str, str, int, int]:
    parts = payload.split(":")
    group_key = parts[1] if len(parts) > 1 else CATEGORY_FALLBACK_KEY
    category_key = parts[2] if len(parts) > 2 else ""

    def _safe_int(value: str, default: int = 1) -> int:
        try:
            return max(1, int(value))
        except (TypeError, ValueError):
            return default

    category_page = _safe_int(parts[3]) if len(parts) > 3 else 1
    settings_page = _safe_int(parts[4]) if len(parts) > 4 else 1
    return group_key, category_key, category_page, settings_page


def _parse_group_payload(payload: str) -> Tuple[str, int]:
    parts = payload.split(":")
    group_key = parts[1] if len(parts) > 1 else CATEGORY_FALLBACK_KEY
    try:
        page = max(1, int(parts[2]))
    except (IndexError, ValueError):
        page = 1
    return group_key, page


async def _resolve_key_from_token(
    callback: types.CallbackQuery, token: str
) -> Optional[str]:
    key = bot_configuration_service.resolve_key_from_token(token)
    if key:
        return key

    await callback.answer("–≠—Ç–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –±–æ–ª—å—à–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞", show_alert=True)
    return None


def _get_grouped_categories() -> List[Tuple[str, str, List[Tuple[str, str, int]]]]:
    categories = bot_configuration_service.get_categories()
    categories_map = {key: (label, count) for key, label, count in categories}
    used: set[str] = set()
    grouped: List[Tuple[str, str, List[Tuple[str, str, int]]]] = []

    for group_key, title, category_keys in CATEGORY_GROUP_DEFINITIONS:
        items: List[Tuple[str, str, int]] = []
        for category_key in category_keys:
            if category_key in categories_map:
                label, count = categories_map[category_key]
                items.append((category_key, label, count))
                used.add(category_key)
        if items:
            grouped.append((group_key, title, items))

    remaining = [
        (key, label, count)
        for key, (label, count) in categories_map.items()
        if key not in used
    ]

    if remaining:
        remaining.sort(key=lambda item: item[1])
        grouped.append((CATEGORY_FALLBACK_KEY, CATEGORY_FALLBACK_TITLE, remaining))

    return grouped


def _build_groups_keyboard() -> types.InlineKeyboardMarkup:
    grouped = _get_grouped_categories()
    rows: list[list[types.InlineKeyboardButton]] = []

    for group_key, title, items in grouped:
        total = sum(count for _, _, count in items)
        rows.append(
            [
                types.InlineKeyboardButton(
                    text=f"{title} ({total})",
                    callback_data=f"botcfg_group:{group_key}:1",
                )
            ]
        )

    rows.append(
        [
            types.InlineKeyboardButton(
                text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
                callback_data="admin_submenu_settings",
            )
        ]
    )

    return types.InlineKeyboardMarkup(inline_keyboard=rows)


def _build_categories_keyboard(
    group_key: str,
    group_title: str,
    categories: List[Tuple[str, str, int]],
    page: int = 1,
) -> types.InlineKeyboardMarkup:
    total_pages = max(1, math.ceil(len(categories) / CATEGORY_PAGE_SIZE))
    page = max(1, min(page, total_pages))

    start = (page - 1) * CATEGORY_PAGE_SIZE
    end = start + CATEGORY_PAGE_SIZE
    sliced = categories[start:end]

    rows: list[list[types.InlineKeyboardButton]] = []
    rows.append(
        [
            types.InlineKeyboardButton(
                text=f"‚Äî {group_title} ‚Äî",
                callback_data="botcfg_group:noop",
            )
        ]
    )

    buttons: List[types.InlineKeyboardButton] = []
    for category_key, label, count in sliced:
        button_text = f"{label} ({count})"
        buttons.append(
            types.InlineKeyboardButton(
                text=button_text,
                callback_data=f"botcfg_cat:{group_key}:{category_key}:{page}:1",
            )
        )

    for chunk in _chunk(buttons, 2):
        rows.append(list(chunk))

    if total_pages > 1:
        nav_row: list[types.InlineKeyboardButton] = []
        if page > 1:
            nav_row.append(
                types.InlineKeyboardButton(
                    text="‚¨ÖÔ∏è",
                    callback_data=f"botcfg_group:{group_key}:{page - 1}",
                )
            )
        nav_row.append(
            types.InlineKeyboardButton(
                text=f"{page}/{total_pages}",
                callback_data="botcfg_group:noop",
            )
        )
        if page < total_pages:
            nav_row.append(
                types.InlineKeyboardButton(
                    text="‚û°Ô∏è",
                    callback_data=f"botcfg_group:{group_key}:{page + 1}",
                )
            )
        rows.append(nav_row)

    rows.append(
        [
            types.InlineKeyboardButton(
                text="‚¨ÖÔ∏è –ö —Ä–∞–∑–¥–µ–ª–∞–º",
                callback_data="admin_bot_config",
            )
        ]
    )

    return types.InlineKeyboardMarkup(inline_keyboard=rows)


def _build_settings_keyboard(
    category_key: str,
    group_key: str,
    category_page: int,
    language: str,
    page: int = 1,
) -> types.InlineKeyboardMarkup:
    definitions = bot_configuration_service.get_settings_for_category(category_key)
    total_pages = max(1, math.ceil(len(definitions) / SETTINGS_PAGE_SIZE))
    page = max(1, min(page, total_pages))

    start = (page - 1) * SETTINGS_PAGE_SIZE
    end = start + SETTINGS_PAGE_SIZE
    sliced = definitions[start:end]

    rows: list[list[types.InlineKeyboardButton]] = []

    for definition in sliced:
        value_preview = bot_configuration_service.format_value_for_list(definition.key)
        button_text = f"{definition.display_name} ¬∑ {value_preview}"
        if len(button_text) > 64:
            button_text = button_text[:63] + "‚Ä¶"
        token = bot_configuration_service.get_callback_token(definition.key)
        rows.append(
            [
                types.InlineKeyboardButton(
                    text=button_text,
                    callback_data=(
                        f"botcfg_setting:{group_key}:{category_page}:{page}:{token}"
                    ),
                )
            ]
        )

    if total_pages > 1:
        nav_row: list[types.InlineKeyboardButton] = []
        if page > 1:
            nav_row.append(
                types.InlineKeyboardButton(
                    text="‚¨ÖÔ∏è",
                    callback_data=(
                        f"botcfg_cat:{group_key}:{category_key}:{category_page}:{page - 1}"
                    ),
                )
            )
        nav_row.append(
            types.InlineKeyboardButton(
                text=f"{page}/{total_pages}", callback_data="botcfg_cat_page:noop"
            )
        )
        if page < total_pages:
            nav_row.append(
                types.InlineKeyboardButton(
                    text="‚û°Ô∏è",
                    callback_data=(
                        f"botcfg_cat:{group_key}:{category_key}:{category_page}:{page + 1}"
                    ),
                )
            )
        rows.append(nav_row)

    rows.append([
        types.InlineKeyboardButton(
            text="‚¨ÖÔ∏è –ö –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º",
            callback_data=f"botcfg_group:{group_key}:{category_page}",
        )
    ])

    return types.InlineKeyboardMarkup(inline_keyboard=rows)


def _build_setting_keyboard(
    key: str,
    group_key: str,
    category_page: int,
    settings_page: int,
) -> types.InlineKeyboardMarkup:
    definition = bot_configuration_service.get_definition(key)
    rows: list[list[types.InlineKeyboardButton]] = []
    token = bot_configuration_service.get_callback_token(key)

    if definition.python_type is bool:
        rows.append([
            types.InlineKeyboardButton(
                text="üîÅ –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å",
                callback_data=(
                    f"botcfg_toggle:{group_key}:{category_page}:{settings_page}:{token}"
                ),
            )
        ])

    if definition.has_choices:
        rows.append([
            types.InlineKeyboardButton(
                text="üìã –í—ã–±—Ä–∞—Ç—å",
                callback_data=(
                    f"botcfg_choices:{group_key}:{category_page}:{settings_page}:{token}"
                ),
            )
        ])

    rows.append([
        types.InlineKeyboardButton(
            text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å",
            callback_data=(
                f"botcfg_edit:{group_key}:{category_page}:{settings_page}:{token}"
            ),
        )
    ])

    if bot_configuration_service.has_override(key):
        rows.append([
            types.InlineKeyboardButton(
                text="‚ôªÔ∏è –°–±—Ä–æ—Å–∏—Ç—å",
                callback_data=(
                    f"botcfg_reset:{group_key}:{category_page}:{settings_page}:{token}"
                ),
            )
        ])

    rows.append([
        types.InlineKeyboardButton(
            text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
            callback_data=(
                f"botcfg_cat:{group_key}:{definition.category_key}:{category_page}:{settings_page}"
            ),
        )
    ])

    return types.InlineKeyboardMarkup(inline_keyboard=rows)


def _build_choices_keyboard(
    key: str,
    group_key: str,
    category_page: int,
    settings_page: int,
) -> types.InlineKeyboardMarkup:
    token = bot_configuration_service.get_callback_token(key)
    choices = bot_configuration_service.get_choices(key)
    current_value = bot_configuration_service.get_current_value(key)

    rows: list[list[types.InlineKeyboardButton]] = []

    for index, (value, label) in enumerate(choices, start=1):
        if isinstance(value, str) and isinstance(current_value, str):
            is_selected = value.lower() == current_value.lower()
        else:
            is_selected = value == current_value
        prefix = "‚úÖ " if is_selected else ""
        rows.append(
            [
                types.InlineKeyboardButton(
                    text=f"{prefix}{label}",
                    callback_data=(
                        f"botcfg_choice_set:{group_key}:{category_page}:{settings_page}:{token}:{index}"
                    ),
                )
            ]
        )

    rows.append(
        [
            types.InlineKeyboardButton(
                text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥",
                callback_data=(
                    f"botcfg_setting:{group_key}:{category_page}:{settings_page}:{token}"
                ),
            )
        ]
    )

    return types.InlineKeyboardMarkup(inline_keyboard=rows)


def _render_setting_text(key: str) -> str:
    summary = bot_configuration_service.get_setting_summary(key)

    lines = [
        "üß© <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∞</b>",
        f"<b>–ù–∞–∑–≤–∞–Ω–∏–µ:</b> {summary['name']}",
        f"<b>–ö–ª—é—á:</b> <code>{summary['key']}</code>",
        f"<b>–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</b> {summary['category_label']}",
        f"<b>–¢–∏–ø:</b> {summary['type']}",
        f"<b>–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:</b> {summary['current']}",
        f"<b>–ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é:</b> {summary['original']}",
        f"<b>–ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –≤ –ë–î:</b> {'‚úÖ –î–∞' if summary['has_override'] else '‚ùå –ù–µ—Ç'}",
    ]

    return "\n".join(lines)


@admin_required
@error_handler
async def show_bot_config_menu(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
):
    keyboard = _build_groups_keyboard()
    await callback.message.edit_text(
        "üß© <b>–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–æ—Ç–∞</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –Ω–∞—Å—Ç—Ä–æ–µ–∫:",
        reply_markup=keyboard,
    )
    await callback.answer()


@admin_required
@error_handler
async def show_bot_config_group(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
):
    group_key, page = _parse_group_payload(callback.data)
    grouped = _get_grouped_categories()
    group_lookup = {key: (title, items) for key, title, items in grouped}

    if group_key not in group_lookup:
        await callback.answer("–≠—Ç–∞ –≥—Ä—É–ø–ø–∞ –±–æ–ª—å—à–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞", show_alert=True)
        return

    group_title, items = group_lookup[group_key]
    keyboard = _build_categories_keyboard(group_key, group_title, items, page)
    await callback.message.edit_text(
        f"üß© <b>{group_title}</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –Ω–∞—Å—Ç—Ä–æ–µ–∫:",
        reply_markup=keyboard,
    )
    await callback.answer()


@admin_required
@error_handler
async def show_bot_config_category(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
):
    group_key, category_key, category_page, settings_page = _parse_category_payload(
        callback.data
    )
    definitions = bot_configuration_service.get_settings_for_category(category_key)

    if not definitions:
        await callback.answer("–í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–∫", show_alert=True)
        return

    category_label = definitions[0].category_label
    keyboard = _build_settings_keyboard(
        category_key,
        group_key,
        category_page,
        db_user.language,
        settings_page,
    )
    await callback.message.edit_text(
        f"üß© <b>{category_label}</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞:",
        reply_markup=keyboard,
    )
    await callback.answer()


@admin_required
@error_handler
async def show_bot_config_setting(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
    state: FSMContext,
):
    parts = callback.data.split(":", 4)
    group_key = parts[1] if len(parts) > 1 else CATEGORY_FALLBACK_KEY
    try:
        category_page = max(1, int(parts[2])) if len(parts) > 2 else 1
    except ValueError:
        category_page = 1
    try:
        settings_page = max(1, int(parts[3])) if len(parts) > 3 else 1
    except ValueError:
        settings_page = 1
    token = parts[4] if len(parts) > 4 else ""
    key = await _resolve_key_from_token(callback, token)
    if not key:
        return
    text = _render_setting_text(key)
    keyboard = _build_setting_keyboard(key, group_key, category_page, settings_page)
    await callback.message.edit_text(text, reply_markup=keyboard)
    await _store_setting_context(
        state,
        key=key,
        group_key=group_key,
        category_page=category_page,
        settings_page=settings_page,
    )
    await callback.answer()


@admin_required
@error_handler
async def start_edit_setting(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
    state: FSMContext,
):
    parts = callback.data.split(":", 4)
    group_key = parts[1] if len(parts) > 1 else CATEGORY_FALLBACK_KEY
    try:
        category_page = max(1, int(parts[2])) if len(parts) > 2 else 1
    except ValueError:
        category_page = 1
    try:
        settings_page = max(1, int(parts[3])) if len(parts) > 3 else 1
    except ValueError:
        settings_page = 1
    token = parts[4] if len(parts) > 4 else ""
    key = await _resolve_key_from_token(callback, token)
    if not key:
        return
    definition = bot_configuration_service.get_definition(key)

    summary = bot_configuration_service.get_setting_summary(key)
    texts = get_texts(db_user.language)

    instructions = [
        "‚úèÔ∏è <b>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</b>",
        f"–ù–∞–∑–≤–∞–Ω–∏–µ: {summary['name']}",
        f"–ö–ª—é—á: <code>{summary['key']}</code>",
        f"–¢–∏–ø: {summary['type']}",
        f"–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {summary['current']}",
        "\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–µ–º.",
    ]

    if definition.is_optional:
        instructions.append("–û—Ç–ø—Ä–∞–≤—å—Ç–µ 'none' –∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ –ø—É—Å—Ç—ã–º –¥–ª—è —Å–±—Ä–æ—Å–∞ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.")

    instructions.append("–î–ª—è –æ—Ç–º–µ–Ω—ã –æ—Ç–ø—Ä–∞–≤—å—Ç–µ 'cancel'.")

    await callback.message.edit_text(
        "\n".join(instructions),
        reply_markup=types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(
                        text=texts.BACK,
                        callback_data=(
                            f"botcfg_setting:{group_key}:{category_page}:{settings_page}:{token}"
                        ),
                    )
                ]
            ]
        ),
    )

    await _store_setting_context(
        state,
        key=key,
        group_key=group_key,
        category_page=category_page,
        settings_page=settings_page,
    )
    await state.set_state(BotConfigStates.waiting_for_value)
    await callback.answer()


@admin_required
@error_handler
async def handle_edit_setting(
    message: types.Message,
    db_user: User,
    db: AsyncSession,
    state: FSMContext,
):
    data = await state.get_data()
    key = data.get("setting_key")
    group_key = data.get("setting_group_key", CATEGORY_FALLBACK_KEY)
    category_page = data.get("setting_category_page", 1)
    settings_page = data.get("setting_settings_page", 1)

    if not key:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        await state.clear()
        return

    try:
        value = bot_configuration_service.parse_user_value(key, message.text or "")
    except ValueError as error:
        await message.answer(f"‚ö†Ô∏è {error}")
        return

    await bot_configuration_service.set_value(db, key, value)
    await db.commit()

    text = _render_setting_text(key)
    keyboard = _build_setting_keyboard(key, group_key, category_page, settings_page)
    await message.answer("‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞")
    await message.answer(text, reply_markup=keyboard)
    await state.clear()
    await _store_setting_context(
        state,
        key=key,
        group_key=group_key,
        category_page=category_page,
        settings_page=settings_page,
    )


@admin_required
@error_handler
async def handle_direct_setting_input(
    message: types.Message,
    db_user: User,
    db: AsyncSession,
    state: FSMContext,
):
    data = await state.get_data()

    key = data.get("setting_key")
    group_key = data.get("setting_group_key", CATEGORY_FALLBACK_KEY)
    category_page = int(data.get("setting_category_page", 1) or 1)
    settings_page = int(data.get("setting_settings_page", 1) or 1)

    if not key:
        return

    try:
        value = bot_configuration_service.parse_user_value(key, message.text or "")
    except ValueError as error:
        await message.answer(f"‚ö†Ô∏è {error}")
        return

    await bot_configuration_service.set_value(db, key, value)
    await db.commit()

    text = _render_setting_text(key)
    keyboard = _build_setting_keyboard(key, group_key, category_page, settings_page)
    await message.answer("‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞")
    await message.answer(text, reply_markup=keyboard)

    await state.clear()
    await _store_setting_context(
        state,
        key=key,
        group_key=group_key,
        category_page=category_page,
        settings_page=settings_page,
    )


@admin_required
@error_handler
async def reset_setting(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
    state: FSMContext,
):
    parts = callback.data.split(":", 4)
    group_key = parts[1] if len(parts) > 1 else CATEGORY_FALLBACK_KEY
    try:
        category_page = max(1, int(parts[2])) if len(parts) > 2 else 1
    except ValueError:
        category_page = 1
    try:
        settings_page = max(1, int(parts[3])) if len(parts) > 3 else 1
    except ValueError:
        settings_page = 1
    token = parts[4] if len(parts) > 4 else ""
    key = await _resolve_key_from_token(callback, token)
    if not key:
        return
    await bot_configuration_service.reset_value(db, key)
    await db.commit()

    text = _render_setting_text(key)
    keyboard = _build_setting_keyboard(key, group_key, category_page, settings_page)
    await callback.message.edit_text(text, reply_markup=keyboard)
    await _store_setting_context(
        state,
        key=key,
        group_key=group_key,
        category_page=category_page,
        settings_page=settings_page,
    )
    await callback.answer("–°–±—Ä–æ—à–µ–Ω–æ –∫ –∑–Ω–∞—á–µ–Ω–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")


@admin_required
@error_handler
async def toggle_setting(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
    state: FSMContext,
):
    parts = callback.data.split(":", 4)
    group_key = parts[1] if len(parts) > 1 else CATEGORY_FALLBACK_KEY
    try:
        category_page = max(1, int(parts[2])) if len(parts) > 2 else 1
    except ValueError:
        category_page = 1
    try:
        settings_page = max(1, int(parts[3])) if len(parts) > 3 else 1
    except ValueError:
        settings_page = 1
    token = parts[4] if len(parts) > 4 else ""
    key = await _resolve_key_from_token(callback, token)
    if not key:
        return
    current = bot_configuration_service.get_current_value(key)
    new_value = not bool(current)
    await bot_configuration_service.set_value(db, key, new_value)
    await db.commit()

    text = _render_setting_text(key)
    keyboard = _build_setting_keyboard(key, group_key, category_page, settings_page)
    await callback.message.edit_text(text, reply_markup=keyboard)
    await _store_setting_context(
        state,
        key=key,
        group_key=group_key,
        category_page=category_page,
        settings_page=settings_page,
    )
    await callback.answer("–û–±–Ω–æ–≤–ª–µ–Ω–æ")


@admin_required
@error_handler
async def show_setting_choices(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
    state: FSMContext,
):
    parts = callback.data.split(":", 5)
    group_key = parts[1] if len(parts) > 1 else CATEGORY_FALLBACK_KEY
    try:
        category_page = max(1, int(parts[2])) if len(parts) > 2 else 1
    except ValueError:
        category_page = 1
    try:
        settings_page = max(1, int(parts[3])) if len(parts) > 3 else 1
    except ValueError:
        settings_page = 1
    token = parts[4] if len(parts) > 4 else ""
    key = await _resolve_key_from_token(callback, token)
    if not key:
        return

    choices = bot_configuration_service.get_choices(key)
    if not choices:
        await callback.answer("–î–ª—è —ç—Ç–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –≤—ã–±–æ—Ä", show_alert=True)
        return

    summary = bot_configuration_service.get_setting_summary(key)
    keyboard = _build_choices_keyboard(key, group_key, category_page, settings_page)

    text = "\n".join(
        [
            "üìã <b>–í—ã–±–æ—Ä –∑–Ω–∞—á–µ–Ω–∏—è</b>",
            f"–ù–∞–∑–≤–∞–Ω–∏–µ: {summary['name']}",
            f"–¢–µ–∫—É—â–∏–π –≤–∞—Ä–∏–∞–Ω—Ç: {summary['current']}",
            "",
            "–í—ã–±–µ—Ä–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ —Å–ø–∏—Å–∫–∞ –Ω–∏–∂–µ.",
        ]
    )

    await callback.message.edit_text(text, reply_markup=keyboard)
    await _store_setting_context(
        state,
        key=key,
        group_key=group_key,
        category_page=category_page,
        settings_page=settings_page,
    )
    await callback.answer()


@admin_required
@error_handler
async def apply_setting_choice(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
    state: FSMContext,
):
    parts = callback.data.split(":", 6)
    group_key = parts[1] if len(parts) > 1 else CATEGORY_FALLBACK_KEY
    try:
        category_page = max(1, int(parts[2])) if len(parts) > 2 else 1
    except ValueError:
        category_page = 1
    try:
        settings_page = max(1, int(parts[3])) if len(parts) > 3 else 1
    except ValueError:
        settings_page = 1
    token = parts[4] if len(parts) > 4 else ""
    key = await _resolve_key_from_token(callback, token)
    if not key:
        return

    choices = bot_configuration_service.get_choices(key)
    if not choices:
        await callback.answer("–í–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è —ç—Ç–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã", show_alert=True)
        return

    try:
        index = max(1, int(parts[5])) if len(parts) > 5 else 1
    except ValueError:
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç", show_alert=True)
        return

    try:
        selected_value, label = choices[index - 1]
    except IndexError:
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç", show_alert=True)
        return

    cast_value = bot_configuration_service.cast_choice_value(key, selected_value)
    await bot_configuration_service.set_value(db, key, cast_value)
    await db.commit()

    text = _render_setting_text(key)
    keyboard = _build_setting_keyboard(key, group_key, category_page, settings_page)
    await callback.message.edit_text(text, reply_markup=keyboard)
    await _store_setting_context(
        state,
        key=key,
        group_key=group_key,
        category_page=category_page,
        settings_page=settings_page,
    )
    await callback.answer(f"–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {label}")


def register_handlers(dp: Dispatcher) -> None:
    dp.callback_query.register(
        show_bot_config_menu,
        F.data == "admin_bot_config",
    )
    dp.callback_query.register(
        show_bot_config_group,
        F.data.startswith("botcfg_group:") & (~F.data.endswith(":noop")),
    )
    dp.callback_query.register(
        show_bot_config_category,
        F.data.startswith("botcfg_cat:"),
    )
    dp.callback_query.register(
        show_bot_config_setting,
        F.data.startswith("botcfg_setting:"),
    )
    dp.callback_query.register(
        show_setting_choices,
        F.data.startswith("botcfg_choices:"),
    )
    dp.callback_query.register(
        apply_setting_choice,
        F.data.startswith("botcfg_choice_set:"),
    )
    dp.callback_query.register(
        start_edit_setting,
        F.data.startswith("botcfg_edit:"),
    )
    dp.callback_query.register(
        reset_setting,
        F.data.startswith("botcfg_reset:"),
    )
    dp.callback_query.register(
        toggle_setting,
        F.data.startswith("botcfg_toggle:"),
    )
    dp.message.register(
        handle_direct_setting_input,
        StateFilter(None),
        F.text,
        BotConfigInputFilter(),
    )
    dp.message.register(
        handle_edit_setting,
        BotConfigStates.waiting_for_value,
    )

